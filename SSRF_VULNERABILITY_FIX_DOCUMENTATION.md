# SSRF (Server-Side Request Forgery) Vulnerability Fix Documentation

## Overview

**Server-Side Request Forgery (SSRF)** occurs when attackers can coerce a server to perform arbitrary requests on their behalf. This vulnerability allows attackers to make HTTP requests from the server to internal or external systems, potentially leading to data disclosure, internal network reconnaissance, and in some cases, remote code execution.

## What is SSRF?

SSRF vulnerabilities occur when a web application accepts user-controlled input to make server-side requests without proper validation. The server acts as a proxy for the attacker, making requests that the attacker cannot make directly.

### Types of SSRF:
1. **Basic SSRF**: Response data is returned to the attacker
2. **Blind SSRF**: No response data is returned, but the request is still made

## Potential Impact

### Critical Impacts:
- **Internal Network Reconnaissance**: Scanning internal ports and services
- **Data Exfiltration**: Accessing sensitive internal APIs and databases  
- **Cloud Metadata Access**: Accessing cloud instance metadata (AWS, Azure, GCP)
- **Local File Access**: Reading local files using `file://` protocol
- **Authentication Bypass**: Using server credentials to access restricted services
- **Remote Code Execution**: In combination with other vulnerabilities

### Real-World Attack Scenarios:

#### 1. AWS Metadata Service Exploitation
```
http://169.254.169.254/latest/meta-data/iam/security-credentials/
```
Attackers can steal AWS credentials and gain full cloud access.

#### 2. Internal Port Scanning
```
http://127.0.0.1:22    # SSH
http://127.0.0.1:3306  # MySQL
http://127.0.0.1:6379  # Redis
```

#### 3. Local File System Access
```
file:///etc/passwd
file:///proc/self/environ
file:///.ssh/id_rsa
```

## Vulnerable Code Example

### NONCOMPLIANT CODE (DO NOT USE)

```javascript
const express = require('express');
const axios = require('axios');
const app = express();

// ❌ VULNERABLE - No input validation or restrictions
app.get('/api/fetch', async (req, res) => {
    const url = req.query.url; // User-controlled input
    
    try {
        // Direct request to user-provided URL - DANGEROUS!
        const response = await axios.get(url);
        res.json(response.data);
    } catch (err) {
        console.error(err);
        res.status(500).json({ error: err.message });
    }
});
```

### Attack Examples Against Vulnerable Code:

```bash
# Internal service access
curl "http://app.com/api/fetch?url=http://localhost:8080/admin"

# AWS metadata service
curl "http://app.com/api/fetch?url=http://169.254.169.254/latest/meta-data/"

# Local file access (if supported)
curl "http://app.com/api/fetch?url=file:///etc/passwd"

# Internal database access
curl "http://app.com/api/fetch?url=http://localhost:3306/"

# Cloud metadata services
curl "http://app.com/api/fetch?url=http://metadata.google.internal/computeMetadata/v1/"
```

## Security Fix Implementation

### COMPLIANT SOLUTION - Multiple Defense Layers

```javascript
const express = require('express');
const axios = require('axios');
const app = express();

// Security logging function
const logEvent = (message) => {
  const timestamp = new Date().toISOString();
  console.log(`[SECURITY] ${timestamp}: ${message}`);
};

// ✅ SECURE - Comprehensive SSRF Protection
app.get('/api/secure-fetch', async (req, res) => {
    const url = req.query.url;
    
    // 1. Input validation
    if (!url) {
        return res.status(400).json({ error: "URL parameter is required" });
    }
    
    try {
        // 2. Parse and validate URL structure
        const parsedUrl = new URL(url);
        
        // 3. Scheme validation - only allow HTTP/HTTPS
        const allowedSchemes = ["http:", "https:"];
        if (!allowedSchemes.includes(parsedUrl.protocol)) {
            logEvent(`SSRF blocked - Invalid scheme: ${parsedUrl.protocol} for URL: ${url}`);
            return res.status(400).json({ 
                error: "Invalid URL scheme. Only HTTP and HTTPS are allowed." 
            });
        }
        
        // 4. Domain allowlist - only trusted domains
        const allowedDomains = [
            "api.example.com",
            "data.example.com", 
            "secure-api.example.org",
            "public-data.trusted.com"
        ];
        
        if (!allowedDomains.includes(parsedUrl.hostname)) {
            logEvent(`SSRF blocked - Untrusted domain: ${parsedUrl.hostname} for URL: ${url}`);
            return res.status(400).json({ 
                error: "Domain not in allowed list",
                allowedDomains: allowedDomains
            });
        }
        
        // 5. Prevent access to private IP ranges
        const privateIpRanges = [
            /^127\./,                    // 127.0.0.0/8 (localhost)
            /^10\./,                     // 10.0.0.0/8
            /^172\.(1[6-9]|2\d|3[0-1])\./, // 172.16.0.0/12
            /^192\.168\./,               // 192.168.0.0/16
            /^169\.254\./,               // 169.254.0.0/16 (link-local)
            /^::1$/,                     // IPv6 localhost
            /^fc00:/,                    // IPv6 private
            /^fe80:/                     // IPv6 link-local
        ];
        
        const isPrivateIp = privateIpRanges.some(range => range.test(parsedUrl.hostname));
        if (isPrivateIp) {
            logEvent(`SSRF blocked - Private IP access: ${parsedUrl.hostname}`);
            return res.status(400).json({ 
                error: "Access to private IP ranges is not allowed" 
            });
        }
        
        // 6. Block dangerous ports
        const blockedPorts = [
            22,    // SSH
            23,    // Telnet
            25,    // SMTP
            53,    // DNS
            110,   // POP3
            143,   // IMAP
            993,   // IMAPS
            995,   // POP3S
            1433,  // SQL Server
            3306,  // MySQL
            5432,  // PostgreSQL
            6379,  // Redis
            27017  // MongoDB
        ];
        
        if (parsedUrl.port && blockedPorts.includes(Number.parseInt(parsedUrl.port))) {
            logEvent(`SSRF blocked - Blocked port: ${parsedUrl.port}`);
            return res.status(400).json({ 
                error: "Access to this port is not allowed" 
            });
        }
        
        // 7. Configure secure axios settings
        const axiosConfig = {
            timeout: 5000,              // 5 second timeout
            maxRedirects: 3,            // Limit redirects
            maxContentLength: 1024 * 1024, // 1MB limit
            validateStatus: (status) => status < 400, // Only 2xx and 3xx
            headers: {
                'User-Agent': 'SecureApp-Fetcher/1.0'
            }
        };
        
        // 8. Make the secure request
        const response = await axios.get(url, axiosConfig);
        
        logEvent(`Secure external fetch successful: ${url}`);
        
        // 9. Return sanitized response
        res.status(200).json({
            success: true,
            url: url,
            status: response.status,
            data: response.data,
            contentType: response.headers['content-type']
        });
        
    } catch (error) {
        // 10. Proper error handling without information disclosure
        if (error.code === 'ENOTFOUND') {
            logEvent(`SSRF fetch failed - DNS resolution: ${url}`);
            return res.status(400).json({ error: "Unable to resolve hostname" });
        } else if (error.code === 'ECONNREFUSED') {
            logEvent(`SSRF fetch failed - Connection refused: ${url}`);
            return res.status(400).json({ error: "Connection refused" });
        } else if (error.code === 'ETIMEDOUT') {
            logEvent(`SSRF fetch failed - Timeout: ${url}`);
            return res.status(400).json({ error: "Request timeout" });
        } else {
            logEvent(`SSRF fetch failed - General error: ${error.message} for URL: ${url}`);
            return res.status(500).json({ error: "Request failed" });
        }
    }
});
```

### Alternative Approach: Predefined Endpoints Only

```javascript
// ✅ MOST SECURE - Only allow predefined endpoints
app.get('/api/fetch-preset', async (req, res) => {
    const { endpoint, params } = req.query;
    
    // Define safe, predefined endpoints
    const allowedEndpoints = {
        'weather': {
            url: 'https://api.openweathermap.org/data/2.5/weather',
            allowedParams: ['q', 'appid', 'units']
        },
        'news': {
            url: 'https://newsapi.org/v2/top-headlines',
            allowedParams: ['country', 'category', 'apiKey']
        },
        'quotes': {
            url: 'https://api.quotable.io/random',
            allowedParams: ['tags', 'author']
        }
    };
    
    if (!allowedEndpoints[endpoint]) {
        return res.status(400).json({ 
            error: "Invalid endpoint",
            allowedEndpoints: Object.keys(allowedEndpoints)
        });
    }
    
    const config = allowedEndpoints[endpoint];
    const url = new URL(config.url);
    
    // Only add allowed query parameters
    if (params) {
        Object.entries(params).forEach(([key, value]) => {
            if (config.allowedParams.includes(key)) {
                url.searchParams.append(key, value);
            }
        });
    }
    
    try {
        const response = await axios.get(url.toString(), {
            timeout: 5000,
            maxRedirects: 3
        });
        
        res.json({
            endpoint: endpoint,
            data: response.data
        });
    } catch (error) {
        res.status(500).json({ error: "Request failed" });
    }
});
```

## Defense-in-Depth Strategy

### 1. Input Validation
- Validate URL format and structure
- Check for required parameters
- Sanitize input data

### 2. Protocol Restrictions
- Only allow HTTP and HTTPS
- Block dangerous protocols (file://, ftp://, gopher://)

### 3. Domain Allowlisting
- Maintain list of trusted domains
- Use exact domain matching
- Avoid regex-based validation for domains

### 4. IP Address Filtering
- Block private IP ranges (RFC 1918)
- Block localhost and loopback addresses
- Block link-local addresses
- Block cloud metadata services

### 5. Port Restrictions
- Block common internal service ports
- Only allow standard HTTP ports (80, 443, 8080, 8443)

### 6. Request Configuration
- Set reasonable timeouts
- Limit redirects
- Restrict response size
- Use secure headers

### 7. Error Handling
- Don't expose internal error details
- Log security events
- Return generic error messages

### 8. Network Segmentation
- Use firewalls to restrict outbound connections
- Implement network policies
- Monitor outbound traffic

## Testing for SSRF Vulnerabilities

### Manual Testing Checklist:

```bash
# 1. Basic SSRF test
curl "http://target.com/fetch?url=http://127.0.0.1:8080"

# 2. Cloud metadata services
curl "http://target.com/fetch?url=http://169.254.169.254/latest/meta-data/"

# 3. Internal service discovery
curl "http://target.com/fetch?url=http://localhost:3306"
curl "http://target.com/fetch?url=http://localhost:6379"
curl "http://target.com/fetch?url=http://localhost:22"

# 4. File system access
curl "http://target.com/fetch?url=file:///etc/passwd"

# 5. Protocol bypass attempts
curl "http://target.com/fetch?url=dict://localhost:11211/stat"
curl "http://target.com/fetch?url=gopher://localhost:3306/"

# 6. DNS rebinding attacks
curl "http://target.com/fetch?url=http://malicious.com" # Points to 127.0.0.1

# 7. URL encoding bypass
curl "http://target.com/fetch?url=http://127.0.0.1%3a8080"
```

### Automated Testing Tools:
- **SSRFmap**: SSRF vulnerability scanner
- **Burp Suite**: Professional web security testing
- **OWASP ZAP**: Open-source security scanner
- **Nuclei**: Fast vulnerability scanner

## Implementation Best Practices

### 1. Use Libraries with SSRF Protection
```javascript
// Use libraries that provide SSRF protection
const { SSRFProtector } = require('ssrf-protection');
const protector = new SSRFProtector({
    allowedDomains: ['api.example.com'],
    blockPrivateIPs: true,
    maxRedirects: 3
});
```

### 2. Implement Request Validation Middleware
```javascript
const validateSSRF = (req, res, next) => {
    const url = req.query.url || req.body.url;
    
    if (!isValidURL(url)) {
        return res.status(400).json({ error: 'Invalid URL' });
    }
    
    if (!isAllowedDomain(url)) {
        return res.status(400).json({ error: 'Domain not allowed' });
    }
    
    next();
};

app.use('/api/fetch', validateSSRF);
```

### 3. Use Environment-Based Configuration
```javascript
const config = {
    allowedDomains: process.env.ALLOWED_DOMAINS?.split(',') || [],
    maxTimeout: process.env.REQUEST_TIMEOUT || 5000,
    maxRedirects: process.env.MAX_REDIRECTS || 3
};
```

## Monitoring and Detection

### Log Events to Monitor:
1. Requests to private IP ranges
2. Requests to blocked ports
3. Multiple failed validation attempts
4. Requests to cloud metadata services
5. Unusual request patterns

### Security Metrics:
- Number of blocked SSRF attempts
- Most targeted internal services
- Source IPs making SSRF attempts
- Common attack patterns

## Conclusion

SSRF vulnerabilities can have severe consequences, from data breaches to complete infrastructure compromise. The key to prevention is implementing multiple layers of security controls:

1. **Validate and sanitize** all user inputs
2. **Use allowlists** instead of blocklists
3. **Implement proper error handling**
4. **Monitor and log** security events
5. **Test regularly** for SSRF vulnerabilities

By following these guidelines and implementing the provided secure code examples, you can effectively protect your application from SSRF attacks.

## References

- [OWASP SSRF Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html)
- [PortSwigger SSRF](https://portswigger.net/web-security/ssrf)
- [CWE-918: Server-Side Request Forgery](https://cwe.mitre.org/data/definitions/918.html)
- [NIST Cybersecurity Framework](https://www.nist.gov/cybersecurity)